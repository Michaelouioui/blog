# 实现小型打包工具

原本小册计划中是没有这一章节的，Webpack 工作原理应该是上一章节包含的内容。但是考虑到既然讲到工作原理，必然需要讲解源码，但是 Webpack 的源码很难读，不结合源码干巴巴讲原理又没有什么价值。所以在这一章节中，我将会带大家来实现一个几十行的迷你打包工具，该工具可以实现以下两个功能

- 将 ES6 转换为 ES5
- 支持在 JS 文件中 `import` CSS 文件

通过这个工具的实现，大家可以理解到打包工具的**原理**到底是什么。

## 实现

因为涉及到 ES6 转 ES5，所以我们首先需要安装一些 Babel 相关的工具

```
yarn add babylon babel-traverse babel-core babel-preset-env  
```

接下来我们将这些工具引入文件中

```
const fs = require('fs')
const path = require('path')
const babylon = require('babylon')
const traverse = require('babel-traverse').default
const { transformFromAst } = require('babel-core')
```

首先，我们先来实现如何使用 Babel 转换代码

```
function readCode(filePath) {
  // 读取文件内容
  const content = fs.readFileSync(filePath, 'utf-8')
  // 生成 AST
  const ast = babylon.parse(content, {
    sourceType: 'module'
  })
  // 寻找当前文件的依赖关系
  const dependencies = []
  traverse(ast, {
    ImportDeclaration: ({ node }) => {
      dependencies.push(node.source.value)
    }
  })
  // 通过 AST 将代码转为 ES5
  const { code } = transformFromAst(ast, null, {
    presets: ['env']
  })
  return {
    filePath,
    dependencies,
    code
  }
}
```

- 首先我们传入一个文件路径参数，然后通过 `fs` 将文件中的内容读取出来
- 接下来我们通过 `babylon` 解析代码获取 AST，目的是为了分析代码中是否还引入了别的文件
- 通过 `dependencies` 来存储文件中的依赖，然后再将 AST 转换为 ES5 代码
- 最后函数返回了一个对象，对象中包含了当前文件路径、当前文件依赖和当前文件转换后的代码

接下来我们需要实现一个函数，这个函数的功能有以下几点

- 调用 `readCode` 函数，传入入口文件
- 分析入口文件的依赖
- 识别 JS 和 CSS 文件

```
function getDependencies(entry) {
  // 读取入口文件
  const entryObject = readCode(entry)
  const dependencies = [entryObject]
  // 遍历所有文件依赖关系
  for (const asset of dependencies) {
    // 获得文件目录
    const dirname = path.dirname(asset.filePath)
    // 遍历当前文件依赖关系
    asset.dependencies.forEach(relativePath => {
      // 获得绝对路径
      const absolutePath = path.join(dirname, relativePath)
      // CSS 文件逻辑就是将代码插入到 `style` 标签中
      if (/\.css$/.test(absolutePath)) {
        const content = fs.readFileSync(absolutePath, 'utf-8')
        const code = `
          const style = document.createElement('style')
          style.innerText = ${JSON.stringify(content).replace(/\\r\\n/g, '')}
          document.head.appendChild(style)
        `
        dependencies.push({
          filePath: absolutePath,
          relativePath,
          dependencies: [],
          code
        })
      } else {
        // JS 代码需要继续查找是否有依赖关系
        const child = readCode(absolutePath)
        child.relativePath = relativePath
        dependencies.push(child)
      }
    })
  }
  return dependencies
}
```

- 首先我们读取入口文件，然后创建一个数组，该数组的目的是存储代码中涉及到的所有文件
- 接下来我们遍历这个数组，一开始这个数组中只有入口文件，在遍历的过程中，如果入口文件有依赖其他的文件，那么就会被 `push` 到这个数组中
- 在遍历的过程中，我们先获得该文件对应的目录，然后遍历当前文件的依赖关系
- 在遍历当前文件依赖关系的过程中，首先生成依赖文件的绝对路径，然后判断当前文件是 CSS 文件还是 JS 文件
  - 如果是 CSS 文件的话，我们就不能用 Babel 去编译了，只需要读取 CSS 文件中的代码，然后创建一个 `style` 标签，将代码插入进标签并且放入 `head` 中即可
  - 如果是 JS 文件的话，我们还需要分析 JS 文件是否还有别的依赖关系
  - 最后将读取文件后的对象 `push` 进数组中

现在我们已经获取到了所有的依赖文件，接下来就是实现打包的功能了

```
function bundle(dependencies, entry) {
  let modules = ''
  // 构建函数参数，生成的结构为
  // { './entry.js': function(module, exports, require) { 代码 } }
  dependencies.forEach(dep => {
    const filePath = dep.relativePath || entry
    modules += `'${filePath}': (
      function (module, exports, require) { ${dep.code} }
    ),`
  })
  // 构建 require 函数，目的是为了获取模块暴露出来的内容
  const result = `
    (function(modules) {
      function require(id) {
        const module = { exports : {} }
        modules[id](module, module.exports, require)
        return module.exports
      }
      require('${entry}')
    })({${modules}})
  `
  // 当生成的内容写入到文件中
  fs.writeFileSync('./bundle.js', result)
}
```

这段代码需要结合着 Babel 转换后的代码来看，这样大家就能理解为什么需要这样写了

```
// entry.js
var _a = require('./a.js')
var _a2 = _interopRequireDefault(_a)
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj }
}
console.log(_a2.default)
// a.js
Object.defineProperty(exports, '__esModule', {
    value: true
})
var a = 1
exports.default = a
```

Babel 将我们 ES6 的模块化代码转换为了 CommonJS（如果你不熟悉 CommonJS 的话，可以阅读这一章节中关于 [模块化的知识点](https://juejin.cn/book/6844733763675488269/section/6844733763759374344)） 的代码，但是浏览器是不支持 CommonJS 的，所以如果这段代码需要在浏览器环境下运行的话，我们需要自己实现 CommonJS 相关的代码，这就是 `bundle` 函数做的大部分事情。

接下来我们再来逐行解析 `bundle` 函数

- 首先遍历所有依赖文件，构建出一个函数参数对象

- 对象的属性就是当前文件的相对路径，属性值是一个函数，函数体是当前文件下的代码，函数接受三个参数

   

  ```
  module
  ```

  、

  ```
  exports
  ```

  、

   

  ```
  require
  ```

  - `module` 参数对应 CommonJS 中的 `module`
  - `exports` 参数对应 CommonJS 中的 `module.export`
  - `require` 参数对应我们自己创建的 `require` 函数

- 接下来就是构造一个使用参数的函数了，函数做的事情很简单，就是内部创建一个 `require` 函数，然后调用 `require(entry)`，也就是 `require('./entry.js')`，这样就会从函数参数中找到 `./entry.js` 对应的函数并执行，最后将导出的内容通过 `module.export` 的方式让外部获取到

- 最后再将打包出来的内容写入到单独的文件中

如果你对于上面的实现还有疑惑的话，可以阅读下打包后的部分简化代码

```
;(function(modules) {
  function require(id) {
    // 构造一个 CommonJS 导出代码
    const module = { exports: {} }
    // 去参数中获取文件对应的函数并执行
    modules[id](module, module.exports, require)
    return module.exports
  }
  require('./entry.js')
})({
  './entry.js': function(module, exports, require) {
    // 这里继续通过构造的 require 去找到 a.js 文件对应的函数
    var _a = require('./a.js')
    console.log(_a2.default)
  },
  './a.js': function(module, exports, require) {
    var a = 1
    // 将 require 函数中的变量 module 变成了这样的结构
    // module.exports = 1
    // 这样就能在外部取到导出的内容了
    exports.default = a
  }
  // 省略
})
```

## 小结

虽然实现这个工具只写了不到 100 行的代码，但是打包工具的核心原理就是这些了

1. 找出入口文件所有的依赖关系
2. 然后通过构建 CommonJS 代码来获取 `exports` 导出的内容

如果大家对于这个章节的内容存在疑问，欢迎在评论区与我互动。

留言

![img](https://p9-passport.byteacctimg.com/img/user-avatar/5e41ee1c076d80557fa78839ed4c71c7~300x300.image)

发表评论

全部评论（37）

[![崔崔崔的头像](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC)](https://juejin.cn/user/958429870174382)

[崔崔崔![lv-1](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/636691cd590f92898cfcda37357472b8.svg)](https://juejin.cn/user/958429870174382)

前端3月前

有点![👍](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/asset/twemoji/2.6.0/svg/1f44d.svg~tplv-t2oaga2asx-image.image)也有点难![[泪奔]](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_85.43ad2fc.png)

点赞

回复

[![Lynnic的头像](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC)](https://juejin.cn/user/4424090522490967)

[Lynnic](https://juejin.cn/user/4424090522490967)

1年前

而且不会有循环引用的问题吗？

点赞

回复

[![Sinosaurus的头像](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC)](https://juejin.cn/user/905653310992782)

[Sinosaurus![lv-1](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/636691cd590f92898cfcda37357472b8.svg)](https://juejin.cn/user/905653310992782)

前端拖油瓶 @ 空空如也1年前

理解的过程中，需要清楚知道哪些是辅助函数用于生成文件的，哪些是会存在生成的文件中的

点赞

回复

[![Lynnic的头像](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC)](https://juejin.cn/user/4424090522490967)

[Lynnic](https://juejin.cn/user/4424090522490967)

1年前

_a2.default _a2根本存在啊

1

1

[![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC)](https://juejin.cn/user/817692381821128)

[热爱学习![lv-2](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/f597b88d22ce5370bd94495780459040.svg)](https://juejin.cn/user/817692381821128)

1年前

@yck,你笔误了

点赞

回复

[![King丶杜若的头像](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC)](https://juejin.cn/user/3878732753016280)

[King丶杜若![lv-1](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/636691cd590f92898cfcda37357472b8.svg)](https://juejin.cn/user/3878732753016280)

前端工程师2年前

读完了发现，整个核心是在实现require函数上，前面所有的操作都在为这个函数服务

1

回复

[![正在加载请稍候的头像](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC)](https://juejin.cn/user/2453765682895527)

[正在加载请稍候![lv-1](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/636691cd590f92898cfcda37357472b8.svg)](https://juejin.cn/user/2453765682895527)

前端开发工程师 @ ？？？2年前

这个案例真的有人跑过么……不说别的……
modules += `'${filePath}': (
 function (module, exports, require) { ${dep.code} }
 ),`
这里的俩括号真的不会报错么………………
代码跑不起来啊……运行报错，并且也读不到require的文件内容啊……

3

回复

[![little123的头像](https://p6-passport.byteacctimg.com/img/user-avatar/cdbdc72ef9fdeecc71db7eeb89c69c07~300x300.image)](https://juejin.cn/user/2013961031258269)

[little123![lv-1](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/636691cd590f92898cfcda37357472b8.svg)](https://juejin.cn/user/2013961031258269)

2年前

用relativePath做文件模块的唯一标识，容易冲突

点赞

回复

[![little123的头像](https://p6-passport.byteacctimg.com/img/user-avatar/cdbdc72ef9fdeecc71db7eeb89c69c07~300x300.image)](https://juejin.cn/user/2013961031258269)

[little123![lv-1](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/636691cd590f92898cfcda37357472b8.svg)](https://juejin.cn/user/2013961031258269)

2年前

在entry.js文件中var _a = require('./a.js')，
在readCode函数中
 ImportDeclaration: ({node}) => {
 //依赖文件的相对路径
 dependencies.push(node.source.value)
 }，
这里并不能识别到require的标识，导致./a.js没有被放到dependencies中。
如果改成 import a from './a.js'则可以被依赖收集到

展开

2

回复

[![超超就是我69532的头像](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC)](https://juejin.cn/user/3808364010408958)

[超超就是我69532](https://juejin.cn/user/3808364010408958)

3年前

对整个打包过程终于有了了解

点赞

回复

[![funwt的头像](https://p26-passport.byteacctimg.com/img/mosaic-legacy/3795/3044413937~300x300.image)](https://juejin.cn/user/2383396937931607)

[funwt](https://juejin.cn/user/2383396937931607)

3年前

getDependencies函数的const dependencies = [entryObject]这一句是不是错了？

点赞

1

[![img](https://p26-passport.byteacctimg.com/img/mosaic-legacy/3795/3044413937~300x300.image)](https://juejin.cn/user/2383396937931607)

[funwt](https://juejin.cn/user/2383396937931607)

3年前

不好意思，是我自己理解错了

点赞

回复

[![胖次超人的头像](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC)](https://juejin.cn/user/2963939079761342)

[胖次超人![lv-1](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/636691cd590f92898cfcda37357472b8.svg)](https://juejin.cn/user/2963939079761342)

前端开发3年前

有点难

2

回复

[![zy_ch的头像](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC)](https://juejin.cn/user/2963939079226200)

[zy_ch![lv-1](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/636691cd590f92898cfcda37357472b8.svg)](https://juejin.cn/user/2963939079226200)

FE @ 东哥兄弟3年前

受教了，之前我用的正则和ejs来实现的，用了transformFromAst方便多了

点赞

回复

[![不躺平中的头像](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC)](https://juejin.cn/user/1380642334995559)

[不躺平中![lv-1](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/636691cd590f92898cfcda37357472b8.svg)](https://juejin.cn/user/1380642334995559)

前端3年前

感谢作者，对webpack打包有了更清晰的思路

点赞

回复

[![大土豆丶的头像](https://p9-passport.byteacctimg.com/img/user-avatar/eeac0a450e05fe74c358fe69af1ae417~300x300.image)](https://juejin.cn/user/3438928101908638)

[大土豆丶](https://juejin.cn/user/3438928101908638)

3年前

太难了-.-

1

回复

[![飞雁的头像](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/18/1685ea940dd7fe60~tplv-t2oaga2asx-no-mark:100:100:100:100.awebp)](https://juejin.cn/user/1151943916662814)

[飞雁](https://juejin.cn/user/1151943916662814)

前端螺丝钉3年前

多看几遍，多看几遍 :sob:

点赞

回复

[![JasonXiaoSpace的头像](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/mirror-assets/168e09c02889ebc2ba4~tplv-t2oaga2asx-no-mark:100:100:100:100.awebp)](https://juejin.cn/user/1961184475223645)

[JasonXiaoSpace](https://juejin.cn/user/1961184475223645)

17zuoye3年前

太生涩了。和国外的官方文档比可读性差太远

2

3

[![img](https://p26-passport.byteacctimg.com/img/user-avatar/a386aa8db73c9678458ec34161472ca5~300x300.image)](https://juejin.cn/user/712139233840407)

[yck![lv-7](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/7a2d00014351211140dd9bc0ba3afd8c.svg)](https://juejin.cn/user/712139233840407)

（作者）3年前

官方文档都开始教怎么实现打包工具了？

1

回复

[![img](https://p6-passport.byteacctimg.com/img/user-avatar/fd7a4cfd0309ac1014f68faf0d724b87~300x300.image)](https://juejin.cn/user/3966693684289965)

[Mrlgm![lv-2](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/f597b88d22ce5370bd94495780459040.svg)](https://juejin.cn/user/3966693684289965)

3年前

章口就来

1

回复

查看更多回复

[![ZedCoding的头像](https://p9-passport.byteacctimg.com/img/user-avatar/5a7bc1423ba1db61723cc44924335708~300x300.image)](https://juejin.cn/user/3790771822532110)

[ZedCoding](https://juejin.cn/user/3790771822532110)

前端 @ 杭州高级切图工作室3年前

这张阅读起来很吃力

点赞

回复

[![啊榮的头像](https://p9-passport.byteacctimg.com/img/user-avatar/f0edb4ad09859df7b58212e856bccbc9~300x300.image)](https://juejin.cn/user/870468940468654)

[啊榮](https://juejin.cn/user/870468940468654)

前端开发 @ midea3年前

对这方面的前端知识严重欠缺

点赞

回复

[![cplayer的头像](https://p6-passport.byteacctimg.com/img/user-avatar/cdc30009db4a22d69d782c6f870ca832~300x300.image)](https://juejin.cn/user/3139860939669965)

[cplayer](https://juejin.cn/user/3139860939669965)

3年前

getDpendencies函数里面没有递归去寻找依赖,怎么会有形成依赖树.

点赞

2

[![img](https://p26-passport.byteacctimg.com/img/user-avatar/a386aa8db73c9678458ec34161472ca5~300x300.image)](https://juejin.cn/user/712139233840407)

[yck![lv-7](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/7a2d00014351211140dd9bc0ba3afd8c.svg)](https://juejin.cn/user/712139233840407)

（作者）3年前

自己试试不就好了

点赞

回复

[![img](https://p9-passport.byteacctimg.com/img/user-avatar/6b653c04d8aaf992b330835785029eb8~300x300.image)](https://juejin.cn/user/3808364010408958)

[超超就是我69532](https://juejin.cn/user/3808364010408958)

3年前

const dependencies = []
traverse(ast, {
ImportDeclaration: ({ node }) => {
dependencies.push(node.source.value)
}
})

点赞

回复

[![一点笔记的头像](https://p26-passport.byteacctimg.com/img/user-avatar/dbf03eebdf6844b37a7158a585bd2dd6~300x300.image)](https://juejin.cn/user/2013961033090311)

[一点笔记![lv-1](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/636691cd590f92898cfcda37357472b8.svg)](https://juejin.cn/user/2013961033090311)

3年前

这章超赞!

点赞

回复

查看全部 37 条回复